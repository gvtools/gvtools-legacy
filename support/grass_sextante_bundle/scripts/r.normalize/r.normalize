#!/bin/sh

############################################################################
#
# MODULE:       r.normalize
# AUTHOR(S):    Benjamin Ducke <benjamin.ducke AT oadigital.net>
# PURPOSE:      Normalizes input data to range [0;1]. Optionally standardizes data.
#
# USAGE:	By default, a simple normalization of the data will be performed,
#		so that the output range will be [0;1]. This is achieved by shifting
#		all data uniformly left or right into range [0..n] and then scaling it
#		by division with the maximum. Two sets of normalized data share the
#		same value range, but may have very different variance (the same
#		as the unscaled data), making it difficult to compare data from 
#		different normal distributions.
#		Therefore, if the "-s" flag is given, the data will be standardized
#		by shifting its mean to "0.0" and dividing all data by the standard 
#		deviation. The resulting z-scores have a normal distribution with
#		mean=0 and variance=1. This allows for comparison of data with
#		different normal distributions.
#
#		In a standardized distribution, 99.9% of the data lies between
#		-3.0 and +3.0. However, this may not be true if there are many 
#		outliers in the data, so trimming or despiking may be recommendable 
#		before standardization of data.		
#
#		This module will work on the entire range of the input data,
#		including extreme values and outliers. If that is unwanted,
#		then r.despike and/or r.trim may be used prior to this module.
#
# COPYRIGHT:    (C) 2010 by Benjamin Ducke
#
#               This program is free software under the GNU General Public
#               License (>=v2). Read the file COPYING that comes with GRASS
#               for details.
#
#############################################################################


#%Module
#% description: Normalizes or standardizes the input data.
#% keywords: raster, normalization, standardization, geophysics, signals
#%End

#%Option
#% key: input
#% type: string
#% required: yes
#% multiple: no
#% key_desc: name
#% description: Name of input raster map
#% gisprompt: old,cell,raster
#%End

#%Option
#% key: output
#% type: string
#% required: yes
#% multiple: no
#% key_desc: name
#% description: Name of (normalized/standardized) output raster map
#% gisprompt: new,cell,raster
#%End

#%Flag
#%  key: s
#%  description: Output standardized z-scores (mean=0, variance=1)
#%End

MODULE_NAME=r.normalize


if [ -z "$GISBASE" ] ; then
	echo "ERROR: You must be in GRASS GIS to run this program." 1>&2
	exit 1
fi

if [ "$1" != "@ARGS_PARSED@" ] ; then
	exec g.parser "$0" "$@"
fi


# setup temporary file
TMP_FILE="`g.tempfile pid=$$`"
if [ $? -ne 0 ] || [ -z "$TMP_FILE" ] ; then
    g.message -e "Unable to create temporary file for statistics. Aborting."
    exit 1
fi

# get statistics
g.message "Getting input data statistics..."
r.univar -g "$GIS_OPT_INPUT" > $TMP_FILE
MIN=`cat "$TMP_FILE" | awk --field-separator="=" 'BEGIN { "grep \"min=\"" | getline } BEGIN { print $2 }'`
MAX=`cat "$TMP_FILE" | awk --field-separator="=" 'BEGIN { "grep \"max=\"" | getline } BEGIN { print $2 }'`
MEAN=`cat "$TMP_FILE" | awk --field-separator="=" 'BEGIN { "grep \"mean=\"" | getline } BEGIN { print $2 }'`
STDDEV=`cat "$TMP_FILE" | awk --field-separator="=" 'BEGIN { "grep \"stddev=\"" | getline } BEGIN { print $2 }'`

# Adjust output range
if [ "$GIS_FLAG_S" = "1" ] ; then
	# This first shifts the data by its (-)mean, so that the
	# mean=0.0. It then divides the shifted data by the stddev.
	# The result are standardized z-scores.
	g.message "Standardizing data:"
	r.mapcalc "$GIS_OPT_OUTPUT=($GIS_OPT_INPUT-$MEAN)/$STDDEV"
else
	# This first shifts the data left or right, so that
	# min=0 and max=max+/-shift, then divides the result
	# by max(+/-shift). The shift is the minimum value *-1,
	# reversing its direction.
	g.message "Normalizing data:"	
	r.mapcalc "$GIS_OPT_OUTPUT=($GIS_OPT_INPUT+(-1)*$MIN)/($MAX+(-1)*$MIN)"
fi

# assign color scale
g.message "Assigning histogram-equalized greyscale..."
if [ "$GIS_FLAG_S" = "1" ] ; then
	r.colors --quiet map=$GIS_OPT_OUTPUT color=grey -e
else
	r.colors --quiet map=$GIS_OPT_OUTPUT color=grey1.0 -e
fi

g.message "Done."

exit 0

