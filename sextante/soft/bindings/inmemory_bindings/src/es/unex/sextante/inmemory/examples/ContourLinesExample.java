

package es.unex.sextante.inmemory.examples;

import java.io.IOException;
import java.util.ArrayList;

import es.unex.sextante.core.OutputFactory;
import es.unex.sextante.core.ParametersSet;
import es.unex.sextante.core.Sextante;
import es.unex.sextante.dataObjects.IVectorLayer;
import es.unex.sextante.exceptions.GeoAlgorithmExecutionException;
import es.unex.sextante.inmemory.core.InMemoryOutputFactory;
import es.unex.sextante.inmemory.core.InMemoryRasterLayer;
import es.unex.sextante.vectorize.contourLines.ContourLinesAlgorithm;


public class ContourLinesExample {

   /*
    * The output factory to use when calling geoalgorithms.
    * This tells the algorithm how to create new data objects (layers
    * and tables)
    * The InMemoryOutputFactory creates objects based on basic java objects
    * and libraries used by SEXTANTE
    * (2D arrays for raster layers and JTS geometries for vector ones), so
    * no additional data handling libraries are needed.
    */
   private static OutputFactory m_OutputFactory = new InMemoryOutputFactory();


   public static void main(final String[] args) {

      initialize();

      try {
         doProcessing();
         System.exit(0);
      }
      catch (final Exception e) {
         e.printStackTrace();
         System.exit(1);
      }

   }


   private static void initialize() {

      /*
       * Initialize the library.
       * This will load all the algorithms and resource strings.
       * Since no language code is passed, default language(en)
       * will be used
       */
      Sextante.initialize();

   }


   private static void doProcessing() throws GeoAlgorithmExecutionException, IOException {

      /*
       * First we need some data.
       * We create an artificial surface (a cone-like one)
       */
      final int SIZE = 500;
      final double dMaxDist = Math.sqrt(SIZE * SIZE + SIZE * SIZE);
      final double[][] dem = new double[SIZE][SIZE];
      for (int x = 0; x < SIZE; x++) {
         for (int y = 0; y < SIZE; y++) {
            final double xDist = SIZE / 2 - x;
            final double yDist = SIZE / 2 - y;
            dem[x][y] = dMaxDist - Math.sqrt(xDist * xDist + yDist * yDist);
         }
      }

      /*
       * To use this data we need to wrap it with an object
       * that implements the IRasterLayer, so SEXTANTE algorithms
       * can access it.
       * We will use the wrapper class InMemoryRasterLayer
       */
      final InMemoryRasterLayer layer = new InMemoryRasterLayer();

      /*
       * To create the layer we need to pass the DEM and some coordinates
       * (in this case, min X and Y coords) and a cellsize as well
       */
      layer.create(dem, 0, 0, 1);

      /*
       * Now we will calculate contour lines from that DEM
       * These lines of code will set up the parameters needed to do it with
       * the corresponding SEXTANTE algorithm, so it takes our in-memory
       * DEM as input.
       */
      final ContourLinesAlgorithm alg = new ContourLinesAlgorithm();
      final ParametersSet params = alg.getParameters();
      params.getParameter(ContourLinesAlgorithm.LAYER).setParameterValue(layer);
      params.getParameter(ContourLinesAlgorithm.DISTANCE).setParameterValue(new Double(100.));
      params.getParameter(ContourLinesAlgorithm.MIN).setParameterValue(new Double(0.));
      params.getParameter(ContourLinesAlgorithm.MAX).setParameterValue(new Double(10000.));


      /*
       * Execute the algorithm. We use no task monitor,
       * so we will not be able to monitor the progress
       * of the execution. SEXTANTE also provides a DefaultTaskMonitor,
       * which shows a simple progress bar, or you could make your
       * own one, implementing the ITaskMonitor interface
       *
       * The execute method returns true if everything went OK, or false if it
       * was canceled. Since we are not giving the user the chance to
       * cancel it (there is no task monitor), we do not care about the
       * return value.
       *
       * If something goes wrong, it will throw an exception.
       */
      alg.execute(null, m_OutputFactory);

      /*
       * Now the result can be taken from the output container.
       * Since we are using the InMemoryOutputFactory, the vector
       * layer generated by the algorithm will be a InMemoryVectorLayer object,
       * which will wrap an arraylist of features with JTS objects as geometries
       */
      final IVectorLayer result = (IVectorLayer) alg.getOutputObjects().getOutput(ContourLinesAlgorithm.RESULT).getOutputObject();

      /*
       * This will give us the inner base object (in this case, the aforementioned ArrayList)
       */
      final ArrayList list = (ArrayList) result.getBaseDataObject();

      /*
       * And now we can do with it whatever we want.
       * Let's print some information to see that the layer has
       * been correctly created.
       */
      System.out.println("This layer contains " + Integer.toString(list.size()) + " lines.");

   }
}
